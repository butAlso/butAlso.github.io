{"pages":[],"posts":[{"title":"在二叉树中分配硬币","text":"题目链接：distribute-coins-in-binary-tree 题目描述给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。返回使每个结点上只有一枚硬币所需的移动次数。 题目分析 要使得硬币移动次数最少，我们应该把结点中多余的硬币移到离它最近且需要硬币的结点上。 由于是在二叉树上移动，则硬币移动轨迹一定是从某结点移动到他的父节点或者子节点上。 从需要硬币的结点到有多余硬币的结点的距离等于从有多余硬币结点的距离到需要硬币的结点的距离。 一个结点可能有两个子节点，因此，如果该结点需要硬币或者有多余的硬币，我们无法一下子确定该硬币应该从左子节点还是右子节点获得或者移向左子节点还是右子节点；而一个结点一定只有一个父节点，因此，如果该结点需要硬币或者有多余的硬币，移动轨迹一定会经过他的父节点。 算法分析采用深度搜索优先的思路，从树的叶子节点出发，如果该结点（设为cur）需要硬币，则从他的父节点获得，如果该结点有多余的硬币，则多余的硬币全部移动向他的父节点。即该结点的初始值为cur.val,从该结点递归到他的父节点，移动次数增加Math.abs(cur.val - 1)。该结点cur.val变为期待的1，如果该结点的值cur.val &gt; 1，则他的父节点的的值cur.parent.val = cur.parent.val + cur.val - 1;如果该结点的值cur.val &lt;= 1,则他的父节点的的值cur.parent.val = cur.parent.val - (-cur.val + 1)。逐步递归，直到遍历完整棵树，则可得出结果。 代码解法一123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int moves = 0; // 记录移动次数 public int distributeCoins(TreeNode root) { dfs(root); return moves; } // 该方法返回值为移动完成后结点cur拥有多余的或者缺少的硬币数量，即cur.val - 1。 public int dfs(TreeNode cur) { if (cur == null) return 0; int l = dfs(cur.left); int r = dfs(cur.right); moves += Math.abs(l) + Math.abs(r); // 总结果加上左右子节点硬币流向父节点或从父节点移动过去需要的次数 return cur.val + l + r - 1; // 当前结点缺少的的或者多余的硬币数量 } } 解法二123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int distributeCoins(TreeNode root) { return dfs(root, null); } // 该方法返回值为移动好当前结点（包括他的子节点，即当前结点表示的树）需要的移动次数 public int dfs(TreeNode cur, TreeNode parent) { if (cur == null) return 0; int l = dfs(cur.left, cur); int r = dfs(cur.right, cur); int result = l + r; // 移动好左右子树需要的移动次数 // 修改当前结点父节点的硬币值 if (cur.val &lt; 1) { // 当前结点硬币值小于1，从父节点移动硬币到当前结点,父节点硬币数量减少 result += (1 - cur.val); parent.val -= (1 - cur.val); } else if (cur.val &gt; 1) { // 当前结点硬币值大于1，将多余的硬币值移动到父节点，父节点硬币数量增加 result += (cur.val - 1); parent.val += (cur.val - 1); } return result; } }","link":"/2019/06/29/distribute-coins-in-binary-tree/"},{"title":"most-stones-removed-with-same-row-or-column","text":"","link":"/2019/07/13/most-stones-removed-with-same-row-or-column/"},{"title":"飞地的数量","text":"题目链接：number-of-enclaves 题目描述给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。 题目分析 这道题其实和leetcode上岛屿的数量那道题目很类似，不同点在于连接到边界的岛屿不计入数量，并且这里要计算的是岛屿的面积（1的数量），不是岛屿的面积。 我们应该从边界开始遍历，要把能连接到边界的陆地1转化成用-1表示（像是地理上的半岛），最后，在重新遍历地图，数出1的数量。 算法深度优先遍历（Depth-first-Search,time: O(M * N),memory：O(M*N）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { int[][] dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 四个方向，上下左右 public int numEnclaves(int[][] A) { int ans = 0; for (int row = 0; row &lt; A.length; row++) { for (int col = 0; col &lt; A[0].length; col++) { // 当在边界且边界这里是陆地（即1）的时候，往下深搜，把连接到这块陆地的所有陆地转化为半岛（-1） if (isBoundary(A, row, col) &amp;&amp; A[row][col] == 1) { dfs(A, row, col); } } } // 计算岛屿的面积 for (int row = 0; row &lt; A.length; row++) for (int col = 0; col &lt; A[0].length; col++) if(A[row][col] == 1) ans++; return ans; } private void dfs(int[][] A, int row, int col) { // 超出地图边界或者非陆地或者已经遍历过的陆地，直接返回 if (outOfBoundary(A, row, col) || A[row][col] == 0 || A[row][col] == -1) return; // 将该陆地标记为岛屿，并遍历 A[row][col] = -1; for (int[] dir : dirs) { dfs(A, row + dir[0], col + dir[1]); } } // 判断地图边界 private boolean isBoundary(int[][] A, int row, int col) { return row == 0 || row == A.length - 1 || col == 0 || col == A[0].length - 1; } // 判断是否超出地图边界 private boolean outOfBoundary(int[][] A, int row, int col) { return row &lt; 0 || row &gt; A.length - 1 || col &lt; 0 || col &gt; A[0].length - 1; } }","link":"/2019/07/06/number-of-enclaves/"},{"title":"由斜杠划分区域","text":"题目链接：regions-cut-by-slashes 题目描述在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。（请注意，反斜杠字符是转义的，因此 \\ 用 “\\“ 表示。）。返回区域的数目。 题目分析 该题目用用图来表示的话，一目了然。可是表示成了字符串之后，就感觉有点不知从何处下手。 想办法将图形表示转化成直观的数组表示法。 算法并查集（Union Find） 由于每个小区域只填充’/‘或者’'，因此，小区域划分最多有三种情况（编号如上图所示）： 编号0和编号1在同一个块，编号2和编号3在同一个块。 编号0和编号2在同一个块，编号1和编号3在同一个块。 编号0， 1， 2， 3都在同一个块。 相邻区域间，他们的编号小区域存在一定会在同一个块的情况。其中： 编号0和上一个区域编号3一定在同一个块。 编号1和左边区域的编号2一定在同一个块。 编号2和右边区域的编号1一定在同一个块。 编号3和下边区域的编号0一定在同一个块。 我们开始给每个小区域编一个唯一的块号，通过遍历区域，达到数出全部唯一块的数目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution { private int[] grids; // 用数组来表示块编号 private int num; // 统计唯一块的数目 public int regionsBySlashes(String[] grid) { int N = grid.length; buildUnionFind(N); // 遍历合并所有的区域 for (int r = 0; r &lt; grid.length; r++) for (int c = 0; c &lt; grid[r].length(); c++) process(r, c, N, grid[r].charAt(c)); return num; } // 构建并查集，初始每个块有一个唯一编号 private void buildUnionFind(int N) { grids = new int[N * N * 4]; num = N * N * 4; for (int i = 0; i &lt; grids.length; i++) grids[i] = i; } // 根据行和列的序号，得到块在数组中的位置 private int getSubSquare(int r, int c, int N, int ith) { return r * N * 4 + c * 4 + ith; } // 寻找块的根编号 private int find(int p) { while (grids[p] != p) { grids[p] = grids[grids[p]]; p = grids[p]; } return p; } // 合并两个块 private void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP != rootQ) num--; // 如果两个块拥有不同的编号，合并后，唯一块的数目减1 grids[rootP] = rootQ; } private void process(int r, int c, int N, char square) { // 获取区域中四个小区域的块编号 int s0 = getSubSquare(r, c, N, 0); int s1 = getSubSquare(r, c, N, 1); int s2 = getSubSquare(r, c, N, 2); int s3 = getSubSquare(r, c, N, 3); // 同一个区域的小区域合并 switch(square) { case '\\\\': union(s0, s2); union(s1, s3); break; case '/': union(s0, s1); union(s2, s3); break; default: union(s0, s1); union(s1, s2); union(s2, s3); } // 相邻区域的合并 if (r &gt; 0) { union(s0, getSubSquare(r - 1, c, N, 3)); } if (r &lt; N - 1) { union(s3, getSubSquare(r + 1, c, N, 0)); } if (c &gt; 0) { union(s1, getSubSquare(r, c - 1, N, 2)); } if (c &lt; N - 1) { union(s2, getSubSquare(r, c + 1, N, 1)); } }} 深度优先搜索（Depth first Search）我们很难从原图中，将该图转化成一个用数字表示的数组。但是，当我们将原图表示成一个规模*2的数组时，他将可以表示如下： 1234 0 1 0 1[&quot;//&quot;, &quot;/ &quot;] =&gt; 1 0 1 0 0 1 0 0 1 0 0 0 我们将数字1当做一道墙，数字0当做一个空白块，则没有墙相隔的块，他们属于同一个唯一块。从上数字中，我们可以直观的看出，一共存在3个唯一块。但是这时，属于同一个唯一空白块的小空白块他们可能还不相邻（即在斜对角线上）。我们再把原图表示成一个规模*3数组，表示如下： 123456 0 0 1 0 0 1 0 1 0 0 1 0[&quot;//&quot;, &quot;/ &quot;] =&gt; 1 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 这时，可以清楚的看出，一共存在3个唯一空白块，且在同一个唯一空白块的所有小空白块，都是相邻的了。这个时候，我们就可以采用深度优先搜索，从数组的边界开始，遍历存在多少个不相邻的0，即可得到答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { int[][] grids; // 表示原图的数组 public int regionsBySlashes(String[] grid) { buildGrids(grid); int count = 0; // 深搜遍历 for (int r = 0; r &lt; grids.length; r++) { for (int c = 0; c &lt; grids[r].length; c++) { count += dfs(r, c); } } return count; } // 将原图表示成规模*3的数组 private void buildGrids(String[] grid) { int N = grid.length; grids = new int[N * 3][N * 3]; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[i].length(); j++) { if (grid[i].charAt(j) == '/') { grids[i * 3 + 2][j * 3] = 1; grids[i * 3 + 1][j * 3 + 1] = 1; grids[i * 3][j * 3 + 2] = 1; } else if (grid[i].charAt(j) == '\\\\') { grids[i * 3][j * 3] = 1; grids[i * 3 + 1][j * 3 + 1] = 1; grids[i * 3 + 2][j * 3 + 2] = 1; } } } } private int dfs(int r, int c) { // 越界返回0 if (r &lt; 0 || r &gt;= grids.length || c &lt; 0 || c &gt;= grids[r].length) return 0; // 遇到墙（数字1）返回0 if (grids[r][c] == 1) return 0; // 将空白块改为1，并向他四周遍历，结果返回1 grids[r][c] = 1; dfs(r - 1, c); dfs(r + 1, c); dfs(r, c - 1); dfs(r, c + 1); return 1; }}","link":"/2019/07/01/regions-cut-by-slashes/"}],"tags":[{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Depth-first-Search","slug":"Depth-first-Search","link":"/tags/Depth-first-Search/"},{"name":"Union-Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"Medium","slug":"leetcode/Medium","link":"/categories/leetcode/Medium/"}]}