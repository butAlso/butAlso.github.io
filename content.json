{"pages":[],"posts":[{"title":"all-nodes-distance-k-in-binary-tree","text":"题目链接：all-nodes-distance-k-in-binary-tree 题目描述给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。 题目分析 距离给定节点距离为K的节点有两种情况：第一种是他的子节点，这种情况比较容易通过遍历得到。第二种是他的祖先节点的其他子树，对于这种情况，我们需要能找到节点的祖先节点的方法。 找到某节点父节点的方法可有两种，一种是深搜回退到他的父节点，一种是建立子节点到父节点的映射。 算法深度优先遍历（Depth-first-Search）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { List&lt;Integer&gt; result; int k; public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) { result = new ArrayList&lt;&gt;(); k = K; dfs(root, target); return result; } public int dfs(TreeNode cur, TreeNode target) { if (cur == null) { return -1; // 返回-1表示在当前子树没有找到目标节点 } if (cur == target) { subtreeAdd(cur, 0); // 找到目标节点了，对目标节点子树进行查找 return 1; // 返回他的父节点到目标节点距离 } else { int d = dfs(cur.left, target); if (d != -1) { // 目标节点在左子树 if (d == k) { // 当前节点符合到目标节点距离，添加到结果集 result.add(cur.val); } subtreeAdd(cur.right, d + 1); // 寻找当前节点右子树符合条件的节点 return d + 1; // 返回当前节点父节点到目标节点的距离 } else { d = dfs(cur.right, target); if (d != -1) { // 目标节点在右子树 if (d == k) { // 当前节点符合到目标节点距离，添加到结果集 result.add(cur.val); } subtreeAdd(cur.left, d + 1); // 寻找当前节点左子树符合条件的节点 return d + 1; // 返回当前节点父节点到目标节点的距离 } } return -1; // 目标节点在当前子树不存在 } } // 查找当前子树符合到目标节点距离的值，保存结果 public void subtreeAdd(TreeNode cur, int d) { if (cur == null || d &gt; k) { return; } if (k == d) { result.add(cur.val); } subtreeAdd(cur.left, d + 1); subtreeAdd(cur.right, d + 1); }} 宽度优先搜索（Breadth-first-Search）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public List&lt;Integer&gt; distanceK(TreeNode root, TreeNode target, int K) { Map&lt;TreeNode, TreeNode&gt; child2parent = new HashMap&lt;&gt;(); dfs(root, null, child2parent); // 建立子节点到父节点的映射 Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(target); queue.offer(null); // 以null为到目标节点距离相同的节点集分割点 HashSet&lt;TreeNode&gt; seen = new HashSet&lt;&gt;(); // 标记查找过的节点，保证入队节点距离目标节点的距离是逐渐增加的 seen.add(target); seen.add(null); List&lt;Integer&gt; result = new ArrayList&lt;&gt;(); // 保存结果 while (!queue.isEmpty()) { TreeNode tmp; if (K == 0) { // 到目标节点距离为K，将当前队列中所有节点集保存到结果，null节点是分割点 while ((tmp = queue.poll()) != null) { result.add(tmp.val); } } else { while ((tmp = queue.poll()) != null) { // 遍历当前距离目标节点距离相等的所有节点，分别将他的父节点、左子节点、右子节点 // 入队（如果这些节点没有被标记过，即他们离目标节点的距离都是+1） if (!seen.contains(tmp.left)) { seen.add(tmp.left); queue.offer(tmp.left); } if (!seen.contains(tmp.right)) { seen.add(tmp.right); queue.offer(tmp.right); } if (!seen.contains(child2parent.get(tmp))) { seen.add(child2parent.get(tmp)); queue.offer(child2parent.get(tmp)); } } queue.offer(null); // null入队分割下次循环 K--; // 目标距离-1 } } return result; } public void dfs(TreeNode cur, TreeNode parent, Map&lt;TreeNode, TreeNode&gt; child2parent) { if (cur != null) { child2parent.put(cur, parent); dfs(cur.left, cur, child2parent); dfs(cur.right, cur, child2parent); } }}","link":"/2019/08/10/all-nodes-distance-k-in-binary-tree/"},{"title":"decode-string","text":"题目链接：decode-string 题目描述给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 题目分析基本上，我们可以理解为只用三种情况 字母字符串，直接返回 数字字符串，后边跟了各’[‘，将他的下层返回的字符字符串加倍存储。 ‘]’一层结束的标志，返回字符字符串。 算法栈（Stack）代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.*;class Solution { public String decodeString(String s) { StringBuilder result = new StringBuilder(); LinkedList&lt;String&gt; stack = new LinkedList&lt;String&gt;(); int index = 0; while (index &lt; s.length()) { if (Character.isLetter(s.charAt(index))) { // 字母字符串 StringBuilder cur = new StringBuilder(); while(index &lt; s.length() &amp;&amp; Character.isLetter(s.charAt(index))) { cur.append(s.charAt(index)); index++; } stack.push(cur.toString()); } else if (Character.isDigit(s.charAt(index))) { // 数字字符串 int j = index; while (Character.isDigit(s.charAt(j))) j++; stack.push(s.substring(index, j)); index = j + 1; } else { while (index &lt; s.length() &amp;&amp; s.charAt(index) == ']') { // 一层结束 StringBuilder tmp = new StringBuilder(); String s2 = stack.pop(); String s1 = stack.pop(); if (Character.isDigit(s1.charAt(0))) { // 将栈里最后两个字符串合并（数字 * 字母） int k = Integer.parseInt(s1); while (k-- &gt; 0) { tmp.append(s2); } index++; } else { // 有可能同一层里套了多个子层，所以，有可能是两个字符串，需要先合并如 \"2[3[a]2[b]]\"， 我们 // 在完成2[b]合并的同时，栈里是[2, aa, bb],我们需要将aa也合并，直到栈里的前一个字符串是数字。 tmp.append(s1); tmp.append(s2); } stack.push(tmp.toString()); } } } // 最外一层合并，如例子 \"3[a]2[bc]\" while (!stack.isEmpty()) { result.append(stack.removeLast()); } return result.toString(); }} 深度优先遍历（Depth-first-Search）事实上，感觉这题不是经典的深搜，更加符合stack的标签，不过理解为深搜也没毛病。 代码123456789101112131415161718192021222324252627282930313233class Solution { public String decodeString(String s) { StringBuilder result = new StringBuilder(); dfs(s.toCharArray(), 0, result); return result.toString(); } public int dfs(char[] cc, int start, StringBuilder str) { while (start &lt; cc.length) { if (Character.isDigit(cc[start])) { int count = 0; while (Character.isDigit(cc[start])) { count = count * 10 + cc[start] - '0'; start++; } StringBuilder inner = new StringBuilder(); // 将下一层解析的字符串结果带回来 int end = dfs(cc, start + 1, inner); while (count-- &gt; 0) str.append(inner.toString()); // 合并 数字 * 字符串 start = end; } else if (Character.isLetter(cc[start])) { // 存储连续的字符串 while (start &lt; cc.length &amp;&amp; Character.isLetter(cc[start])) { str.append(cc[start]); start++; } } else { // ‘]'字符，返回这层结束后的下一个index return start + 1; } } return start; }}","link":"/2019/08/18/decode-string/"},{"title":"friend-circles","text":"题目链接：friend-circles 题目描述班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。 题目分析 要求返回的是朋友圈总数，即不相连的朋友圈数量，典型深搜和并查集题目。 算法深度优先遍历（Depth-first-Search）代码123456789101112131415161718192021222324class Solution { public int findCircleNum(int[][] M) { int result = 0; for (int row = 0; row &lt; M.length; row++) { // 遍历每个学生 result += dfs(M, row); } return result; } public int dfs(int[][] M, int row) { if (M[row][row] == 0) return 0; // 该学生已经被深搜遍历过 for (int col = 0; col &lt; M.length; col++) { if (M[row][col] == 1) { // row, col表示两个人，他们是朋友，从row遍历到col M[row][col] = 0; M[col][row] = 0; dfs(M, col); } } return 1; } } 并查集（Union-Find）代码1234567891011121314151617181920212223242526272829303132333435363738394041class Solution { public int findCircleNum(int[][] M) { UnionFind uf = new UnionFind(M.length); for (int row = 0; row &lt; M.length; row++) { for (int col = 0; col &lt; M.length; col++) { if (M[row][col] == 1) uf.union(row, col); // 两人是朋友，合并朋友圈 } } return uf.count; } class UnionFind { int[] parents; int count; // 统计parents[id] == id的数量 UnionFind(int n) { parents = new int[n]; count = n; for (int i = 0; i &lt; n; i++) { parents[i] = i; } } public int find(int p) { while (parents[p] != p) { parents[p] = parents[parents[p]]; p = parents[p]; } return p; } public void union(int p, int q) { if (find(p) != find(q)) { // 两者合并，parents[id] == id的数量减1 count--; parents[find(p)] = find(q); } } } }","link":"/2019/07/27/friend-circles/"},{"title":"house-robber-iii","text":"题目链接：house-robber-iii 题目描述在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。 题目分析不相邻的节点和最大值，让我们可以分成两种情况： 该节点值 + 他的间接子树最大值的和 他的直接子树最大值的和 算法深度优先遍历（Depth-first-Search）代码1234567891011121314151617181920212223/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int rob(TreeNode root) { return dfs(root); } public int dfs(TreeNode root) { if (root == null) return 0; int result = root.val; if (root.left != null) result += dfs(root.left.left) + dfs(root.left.right); // 该节点左间接子树和最大值 if (root.right != null) result += dfs(root.right.left) + dfs(root.right.right); // 该节点右间接子树和最大值 result = Math.max(result, dfs(root.left) + dfs(root.right)); // 比较选择包含该节点还是不包含该节点的和最大值 return result; }} 深度优先遍历（优化）（Depth-first-Search）在上一解法中，明显可以发现，我们在寻找当前树的最大值时，还需要寻找子树的子树最大值，而在寻找子树的最大值时，我们已经查找过了子树的子树的最大值，即有很多计算是重复的。因此，在深搜过程中，同时返回包含该节点和最大值和不包含该节点和最大值可以给我们运行时间上带来不少优化。 代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int rob(TreeNode root) { int[] result = dfs(root); return Math.max(result[0], result[1]); } // [0] =&gt; 包含该节点的和最大值 // [1] =&gt; 不包含该节点的和最大值 public int[] dfs(TreeNode root) { if (root == null) return new int[]{0, 0}; int result = root.val; int[] l = dfs(root.left); int[] r = dfs(root.right); return new int[] { root.val + l[1] + r[1], Math.max(l[0], l[1]) + Math.max(r[0], r[1]) }; }}","link":"/2019/08/17/house-robber-iii/"},{"title":"在二叉树中分配硬币","text":"题目链接：distribute-coins-in-binary-tree 题目描述给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。返回使每个结点上只有一枚硬币所需的移动次数。 题目分析 要使得硬币移动次数最少，我们应该把结点中多余的硬币移到离它最近且需要硬币的结点上。 由于是在二叉树上移动，则硬币移动轨迹一定是从某结点移动到他的父节点或者子节点上。 从需要硬币的结点到有多余硬币的结点的距离等于从有多余硬币结点的距离到需要硬币的结点的距离。 一个结点可能有两个子节点，因此，如果该结点需要硬币或者有多余的硬币，我们无法一下子确定该硬币应该从左子节点还是右子节点获得或者移向左子节点还是右子节点；而一个结点一定只有一个父节点，因此，如果该结点需要硬币或者有多余的硬币，移动轨迹一定会经过他的父节点。 算法分析采用深度搜索优先的思路，从树的叶子节点出发，如果该结点（设为cur）需要硬币，则从他的父节点获得，如果该结点有多余的硬币，则多余的硬币全部移动向他的父节点。即该结点的初始值为cur.val,从该结点递归到他的父节点，移动次数增加Math.abs(cur.val - 1)。该结点cur.val变为期待的1，如果该结点的值cur.val &gt; 1，则他的父节点的的值cur.parent.val = cur.parent.val + cur.val - 1;如果该结点的值cur.val &lt;= 1,则他的父节点的的值cur.parent.val = cur.parent.val - (-cur.val + 1)。逐步递归，直到遍历完整棵树，则可得出结果。 代码解法一123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { int moves = 0; // 记录移动次数 public int distributeCoins(TreeNode root) { dfs(root); return moves; } // 该方法返回值为移动完成后结点cur拥有多余的或者缺少的硬币数量，即cur.val - 1。 public int dfs(TreeNode cur) { if (cur == null) return 0; int l = dfs(cur.left); int r = dfs(cur.right); moves += Math.abs(l) + Math.abs(r); // 总结果加上左右子节点硬币流向父节点或从父节点移动过去需要的次数 return cur.val + l + r - 1; // 当前结点缺少的的或者多余的硬币数量 } } 解法二123456789101112131415161718192021222324252627282930313233343536/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */class Solution { public int distributeCoins(TreeNode root) { return dfs(root, null); } // 该方法返回值为移动好当前结点（包括他的子节点，即当前结点表示的树）需要的移动次数 public int dfs(TreeNode cur, TreeNode parent) { if (cur == null) return 0; int l = dfs(cur.left, cur); int r = dfs(cur.right, cur); int result = l + r; // 移动好左右子树需要的移动次数 // 修改当前结点父节点的硬币值 if (cur.val &lt; 1) { // 当前结点硬币值小于1，从父节点移动硬币到当前结点,父节点硬币数量减少 result += (1 - cur.val); parent.val -= (1 - cur.val); } else if (cur.val &gt; 1) { // 当前结点硬币值大于1，将多余的硬币值移动到父节点，父节点硬币数量增加 result += (cur.val - 1); parent.val += (cur.val - 1); } return result; } }","link":"/2019/06/29/distribute-coins-in-binary-tree/"},{"title":"飞地的数量","text":"题目链接：number-of-enclaves 题目描述给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。 题目分析 这道题其实和leetcode上岛屿的数量那道题目很类似，不同点在于连接到边界的岛屿不计入数量，并且这里要计算的是岛屿的面积（1的数量），不是岛屿的面积。 我们应该从边界开始遍历，要把能连接到边界的陆地1转化成用-1表示（像是地理上的半岛），最后，在重新遍历地图，数出1的数量。 算法深度优先遍历（Depth-first-Search,time: O(M * N),memory：O(M*N）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution { int[][] dirs = { {-1, 0}, {1, 0}, {0, -1}, {0, 1} }; // 四个方向，上下左右 public int numEnclaves(int[][] A) { int ans = 0; for (int row = 0; row &lt; A.length; row++) { for (int col = 0; col &lt; A[0].length; col++) { // 当在边界且边界这里是陆地（即1）的时候，往下深搜，把连接到这块陆地的所有陆地转化为半岛（-1） if (isBoundary(A, row, col) &amp;&amp; A[row][col] == 1) { dfs(A, row, col); } } } // 计算岛屿的面积 for (int row = 0; row &lt; A.length; row++) for (int col = 0; col &lt; A[0].length; col++) if(A[row][col] == 1) ans++; return ans; } private void dfs(int[][] A, int row, int col) { // 超出地图边界或者非陆地或者已经遍历过的陆地，直接返回 if (outOfBoundary(A, row, col) || A[row][col] == 0 || A[row][col] == -1) return; // 将该陆地标记为岛屿，并遍历 A[row][col] = -1; for (int[] dir : dirs) { dfs(A, row + dir[0], col + dir[1]); } } // 判断地图边界 private boolean isBoundary(int[][] A, int row, int col) { return row == 0 || row == A.length - 1 || col == 0 || col == A[0].length - 1; } // 判断是否超出地图边界 private boolean outOfBoundary(int[][] A, int row, int col) { return row &lt; 0 || row &gt; A.length - 1 || col &lt; 0 || col &gt; A[0].length - 1; } }","link":"/2019/07/06/number-of-enclaves/"},{"title":"移除最多的同行或同列石头","text":"题目链接：most-stones-removed-with-same-row-or-column 题目描述在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。现在，move 操作将会移除与网格上的某一块石头共享一列或一行的一块石头。我们最多能执行多少次 move 操作？ 题目分析 刚开始看到这道题目的时候，一脸蒙蔽，不是很明白最多move操作的意思，然后把示例画成二维图，试了一下，终于明白，这道题目的意思是，让最终每行每列上最多只能有一块石头，最少剩下多少块石头，然后返回原石头数量-剩余石头数量。 很显然，这道题目可以使用深度优先搜索和并查集的方法。我们可以将每行每列定义为一个component，将有石头相连的component合并成一个（并查集的方法），最后在统计有多少个独立的component，即剩下的石头数量；也可以对每块石头所在的component执行一个深度优先遍历，最后统计有从入口执行了多少次，即剩下的石头数量。 算法深度优先遍历（Depth-first-Search,time: O(N2),memory：O(N）代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.*;class Solution { public int removeStones(int[][] stones) { int N = stones.length; // 这里无所谓行和列的概念，我们将行和列都当做一个component， // graph[i][0]记录了第i块石头的邻居数量。 int[][] graph = new int[N][N]; for (int i = 0; i &lt; N; i++) { for (int j = i + 1; j &lt; N; j++) { // 两块石头在同一行或同一列，将他们记录为邻居 if (stones[i][0] == stones[j][0] || stones[i][1] == stones[j][1]) { graph[i][++graph[i][0]] = j; graph[j][++graph[j][0]] = i; } } } boolean[] seen = new boolean[N]; // 深搜遍历过的标志，避免死循环 int ans = 0; for (int i = 0; i &lt; N; i++) { if (!seen[i]) { seen[i] = true; Stack&lt;Integer&gt; stack = new Stack&lt;&gt;(); ans--; stack.push(i); while (!stack.isEmpty()) { int cur = stack.pop(); ans++; // 将该块石头的所有邻居推入\b栈 for (int j = 1; j &lt;= graph[cur][0]; j++) { if (!seen[graph[cur][j]]) { seen[graph[cur][j]] = true; stack.push(graph[cur][j]); } } } } } return ans; } } 并查集（Union-Find,time: O(NlogN),memory：O(N）代码123456789101112131415161718192021222324252627282930313233343536import java.util.*;class Solution { public int removeStones(int[][] stones) { int N = stones.length; DSU dsu = new DSU(20000); // 将这块石头所在行和列合并成一个component // 最终，能合并在一起的石头会拥有同样的parent for (int i = 0; i &lt; N; i++) dsu.union(stones[i][0], stones[i][1] + 10000); HashSet&lt;Integer&gt; seen = new HashSet&lt;&gt;(); // 遍历所有的石头，找出它的父节点，即最后剩余的最少石头数量。 for (int i = 0; i &lt; N; i++) seen.add(dsu.find(stones[i][0])); return N - seen.size(); } class DSU { int[] parent; public DSU(int n) { parent = new int[n]; for (int i = 0; i &lt; n; i++) parent[i] = i; } public int find(int p) { if (parent[p] != p) parent[p] = find(parent[p]); return parent[p]; } public void union(int p, int q) { parent[find(p)] = find(q); } } }","link":"/2019/07/13/most-stones-removed-with-same-row-or-column/"},{"title":"loud-and-rich","text":"题目链接：loud-and-rich 题目描述在一组 N 个人（编号为 0, 1, 2, …, N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。为了方便起见，我们将编号为 x 的人简称为 “person x “。如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人） 题目分析 直观上看，对每个人，我们需要找出比他有钱或者和他一样有钱（他自己）的人，然后比较找出这些人（包括他自己）中最安静的一个作为结果。（解法1） 事实上，在寻找结果过程中，我们没必要找出所有比他有钱的人，比如A比B有钱，C比A有钱，在查找过程中，对于B，我们没有必要同时比较A、B、C三个人的安静值，我们可以先比较A、C的安静值，将min(A, C)结果存起来，然后再比较min(min(A, C), B)的值，即得出比B有钱且最安静的人。（解法2） 算法深度优先遍历（Depth-first-Search）代码12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;class Solution { public int[] loudAndRich(int[][] richer, int[] quiet) { int N = quiet.length; Map&lt;Integer, Set&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // value值存的是比key值更有钱的人 for (int[] r : richer) { Set&lt;Integer&gt; tmp = map.getOrDefault(r[1], new HashSet&lt;&gt;()); tmp.add(r[0]); map.put(r[1], tmp); } for (int i = 0; i &lt; N; i++) { // 遍历深搜，对每个人，找出比他更有钱的人 Set&lt;Integer&gt; tmp = new HashSet&lt;&gt;(); dfs(map, tmp, i); map.put(i, tmp); } int[] result = new int[N]; for (int i = 0; i &lt; N; i++) { // 比较，对每个人，从比他更有钱的人找出最安静的人 result[i] = i; for (int p : map.get(i)) { if (quiet[result[i]] &gt; quiet[p]) result[i] = p; } } return result; } public void dfs(Map&lt;Integer, Set&lt;Integer&gt;&gt; map, Set&lt;Integer&gt; cur, int j) { Set&lt;Integer&gt; tmp = new HashSet&lt;&gt;(map.getOrDefault(j, new HashSet&lt;&gt;())); for (int richer : tmp) { if (!cur.contains(richer)) { cur.add(richer); dfs(map, cur, richer); } } } } 深度优先遍历（优化）（Depth-first-Search）代码12345678910111213141516171819202122232425262728293031323334353637383940import java.util.*;class Solution { List&lt;Integer&gt;[] graph; // 同解法1map,graph[i]表示比i更有钱的人（不完全集合） int[] result; int[] quiet; public int[] loudAndRich(int[][] richer, int[] quiet) { int N = quiet.length; graph = new ArrayList[N]; result = new int[N]; this.quiet = quiet; for (int i = 0; i &lt; N; i++) { graph[i] = new ArrayList&lt;Integer&gt;(); result[i] = -1; } for (int[] edge : richer) { graph[edge[1]].add(edge[0]); } for (int node = 0; node &lt; N; node++) { dfs(node); } return result; } // 返回比node更有钱或同样有钱（包括他自己）的人中最安静的人的编号 public int dfs(int node) { if (result[node] == -1) { result[node] = node; for (int child : graph[node]) { int cand = dfs(child); if (quiet[cand] &lt; quiet[result[node]]) { result[node] = cand; } } } return result[node]; } }","link":"/2019/08/17/loud-and-rich/"},{"title":"pyramid-transition-matrix","text":"题目链接：pyramid-transition-matrix 题目描述现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示，例如 “Z”。使用三元组表示金字塔的堆砌规则如下：(A, B, C) 表示，“C”为顶层方块，方块“A”、“B”分别作为方块“C”下一层的的左、右子块。当且仅当(A, B, C)是被允许的三元组，我们才可以将其堆砌上。初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。如果可以由基层一直堆到塔尖返回true，否则返回false。 题目分析 首先，看完题目，我们可以很清楚的知道，我们需要将每层的各种可能性组合起来，然后不断往金字塔顶部迭代（递归），找到一种可能性。 由于每层的方块数都不一致，因此，我们不能以层作为递归条件，而且，可能有好多层，for循环次数不一致。应该以每个块作为递归条件，在每次递归中，再加以判断是不是应该换层。 算法深度优先遍历（Depth-first-Search）代码1234567891011121314151617181920212223class Solution { public boolean pyramidTransition(String bottom, List&lt;String&gt; allowed) { Map&lt;String, List&lt;Character&gt;&gt; map = new HashMap&lt;&gt;(); // 可堆砌块的映射 for (String s : allowed) { String key = s.substring(0, 2); List&lt;Character&gt; vals = map.getOrDefault(key, new ArrayList&lt;Character&gt;()); vals.add(s.charAt(2)); map.put(key, vals); } return dfs(bottom, map, \"\"); } private boolean dfs(String bottom, Map&lt;String, List&lt;Character&gt;&gt; map, String path) { if (bottom.length() == 1) return true; // 到达金字塔顶端，返回true if (bottom.length() == path.length() + 1) return dfs(path, map, \"\"); // 当前一个层完成，进入下一层 String key = bottom.substring(path.length(), path.length() + 2); for (Character c : map.getOrDefault(key, new ArrayList&lt;Character&gt;())) { if (dfs(bottom, map, path + c)) return true; // 递归遍历，每个砖块 } return false; } } 深度优先遍历+位运算（Depth-first-Search + Bit-Manipulation）代码1234567891011121314151617181920212223242526272829class Solution { int N = 7; // 题目里只有7中方块 public boolean pyramidTransition(String bottom, List&lt;String&gt; allowed) { int[][] blocks = new int[N][N]; for (String s : allowed) { blocks[s.charAt(0) - 'A'][s.charAt(1) - 'A'] |= (1 &lt;&lt; (s.charAt(2) - 'A')); // 类似上一解法中的map } int[][] pyramids = new int[bottom.length()][]; for (int i = 0; i &lt; bottom.length(); i++) { pyramids[i] = new int[bottom.length() - i]; // 第i层砖块长度 pyramids[0][i] = bottom.charAt(i) - 'A'; // 初始层砖块 } return dfs(pyramids, blocks, 1, 0); } private boolean dfs(int[][] pyramids, int[][] blocks, int level, int pos) { if (level == pyramids.length) return true; // 金字塔构建完成 if (pos == pyramids[level].length) return dfs(pyramids, blocks, level + 1, 0); // 进入下一层 int mask = blocks[pyramids[level - 1][pos]][pyramids[level - 1][pos + 1]]; // 当前两个砖块可以堆叠的全部可能性 for (int i = 0; i &lt; N; i++) { if ((mask &amp; (1 &lt;&lt; i)) != 0) { pyramids[level][pos] = i; if (dfs(pyramids, blocks, level, pos + 1)) return true; } } return false; }}","link":"/2019/08/03/pyramid-transition-matrix/"},{"title":"minesweeper","text":"题目链接：minesweeper 题目描述让我们一起来玩扫雷游戏！给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板： 如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。 如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的方块都应该被递归地揭露。 如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。 如果在此次点击中，若无更多方块可被揭露，则返回面板。 题目分析 这里的相邻是上下左右和四个对角线，注意不是只有上下左右 算法深度优先遍历（Depth-first-Search）代码123456789101112131415161718192021222324252627282930313233343536373839404142class Solution { public char[][] updateBoard(char[][] board, int[] click) { int row = click[0]; int col = click[1]; if (board[row][col] == 'M') board[row][col] = 'X'; // 踩雷直接返回 else dfs(board, row, col); return board; } private void dfs(char[][] board, int row, int col) { if (isOutOfBoundary(board, row, col) || board[row][col] != 'E') return; // 越界或已经遍历过 int mines = getNumOfMinesAround(board, row, col); if (mines == 0) { // 周围地雷数量为0，才会递归遍历 board[row][col] = 'B'; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { dfs(board, row + i, col + j); } } } else { board[row][col] = (char)('0' + mines); } } // 获取周围地雷数量 public int getNumOfMinesAround(char[][] board, int row, int col) { int result = 0; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { if ((i == j &amp;&amp; i == 0) || isOutOfBoundary(board, row + i, col + j)) continue; if (board[row+i][col+j] == 'M') result++; } } return result; } // 判断是否越界 public boolean isOutOfBoundary(char[][] board, int row, int col) { return row &lt; 0 || row &gt;= board.length || col &lt; 0 || col &gt;= board[0].length; }} 广度优先遍历（Breadth-first-Search）代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution { public char[][] updateBoard(char[][] board, int[] click) { int row = click[0]; int col = click[1]; if (board[row][col] == 'M') { // 踩雷直接返回 board[row][col] = 'X'; return board; } Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;(); queue.offer(click); while (!queue.isEmpty()) { click = queue.poll(); row = click[0]; col = click[1]; if (isOutOfBoundary(board, row, col) || board[row][col] != 'E') continue; // 越界或已经遍历过 int mines = getNumOfMinesAround(board, row, col); if (mines == 0) { // 周围地雷数量为0，入队遍历 board[row][col] = 'B'; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { queue.offer(new int[]{row + i, col + j}); } } } else { board[row][col] = (char)('0' + mines); } } return board; } // 获取周围地雷数量 public int getNumOfMinesAround(char[][] board, int row, int col) { int result = 0; for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { if ((i == j &amp;&amp; i == 0) || isOutOfBoundary(board, row + i, col + j)) continue; if (board[row+i][col+j] == 'M') result++; } } return result; } // 判断是否越界 public boolean isOutOfBoundary(char[][] board, int row, int col) { return row &lt; 0 || row &gt;= board.length || col &lt; 0 || col &gt;= board[0].length; }}","link":"/2019/07/27/minesweeper/"},{"title":"由斜杠划分区域","text":"题目链接：regions-cut-by-slashes 题目描述在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\\ 或空格构成。这些字符会将方块划分为一些共边的区域。（请注意，反斜杠字符是转义的，因此 \\ 用 “\\“ 表示。）。返回区域的数目。 题目分析 该题目用用图来表示的话，一目了然。可是表示成了字符串之后，就感觉有点不知从何处下手。 想办法将图形表示转化成直观的数组表示法。 算法并查集（Union Find） 由于每个小区域只填充’/‘或者’'，因此，小区域划分最多有三种情况（编号如上图所示）： 编号0和编号1在同一个块，编号2和编号3在同一个块。 编号0和编号2在同一个块，编号1和编号3在同一个块。 编号0， 1， 2， 3都在同一个块。 相邻区域间，他们的编号小区域存在一定会在同一个块的情况。其中： 编号0和上一个区域编号3一定在同一个块。 编号1和左边区域的编号2一定在同一个块。 编号2和右边区域的编号1一定在同一个块。 编号3和下边区域的编号0一定在同一个块。 我们开始给每个小区域编一个唯一的块号，通过遍历区域，达到数出全部唯一块的数目。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384class Solution { private int[] grids; // 用数组来表示块编号 private int num; // 统计唯一块的数目 public int regionsBySlashes(String[] grid) { int N = grid.length; buildUnionFind(N); // 遍历合并所有的区域 for (int r = 0; r &lt; grid.length; r++) for (int c = 0; c &lt; grid[r].length(); c++) process(r, c, N, grid[r].charAt(c)); return num; } // 构建并查集，初始每个块有一个唯一编号 private void buildUnionFind(int N) { grids = new int[N * N * 4]; num = N * N * 4; for (int i = 0; i &lt; grids.length; i++) grids[i] = i; } // 根据行和列的序号，得到块在数组中的位置 private int getSubSquare(int r, int c, int N, int ith) { return r * N * 4 + c * 4 + ith; } // 寻找块的根编号 private int find(int p) { while (grids[p] != p) { grids[p] = grids[grids[p]]; p = grids[p]; } return p; } // 合并两个块 private void union(int p, int q) { int rootP = find(p); int rootQ = find(q); if (rootP != rootQ) num--; // 如果两个块拥有不同的编号，合并后，唯一块的数目减1 grids[rootP] = rootQ; } private void process(int r, int c, int N, char square) { // 获取区域中四个小区域的块编号 int s0 = getSubSquare(r, c, N, 0); int s1 = getSubSquare(r, c, N, 1); int s2 = getSubSquare(r, c, N, 2); int s3 = getSubSquare(r, c, N, 3); // 同一个区域的小区域合并 switch(square) { case '\\\\': union(s0, s2); union(s1, s3); break; case '/': union(s0, s1); union(s2, s3); break; default: union(s0, s1); union(s1, s2); union(s2, s3); } // 相邻区域的合并 if (r &gt; 0) { union(s0, getSubSquare(r - 1, c, N, 3)); } if (r &lt; N - 1) { union(s3, getSubSquare(r + 1, c, N, 0)); } if (c &gt; 0) { union(s1, getSubSquare(r, c - 1, N, 2)); } if (c &lt; N - 1) { union(s2, getSubSquare(r, c + 1, N, 1)); } }} 深度优先搜索（Depth first Search）我们很难从原图中，将该图转化成一个用数字表示的数组。但是，当我们将原图表示成一个规模*2的数组时，他将可以表示如下： 1234 0 1 0 1[&quot;//&quot;, &quot;/ &quot;] =&gt; 1 0 1 0 0 1 0 0 1 0 0 0 我们将数字1当做一道墙，数字0当做一个空白块，则没有墙相隔的块，他们属于同一个唯一块。从上数字中，我们可以直观的看出，一共存在3个唯一块。但是这时，属于同一个唯一空白块的小空白块他们可能还不相邻（即在斜对角线上）。我们再把原图表示成一个规模*3数组，表示如下： 123456 0 0 1 0 0 1 0 1 0 0 1 0[&quot;//&quot;, &quot;/ &quot;] =&gt; 1 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 这时，可以清楚的看出，一共存在3个唯一空白块，且在同一个唯一空白块的所有小空白块，都是相邻的了。这个时候，我们就可以采用深度优先搜索，从数组的边界开始，遍历存在多少个不相邻的0，即可得到答案。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution { int[][] grids; // 表示原图的数组 public int regionsBySlashes(String[] grid) { buildGrids(grid); int count = 0; // 深搜遍历 for (int r = 0; r &lt; grids.length; r++) { for (int c = 0; c &lt; grids[r].length; c++) { count += dfs(r, c); } } return count; } // 将原图表示成规模*3的数组 private void buildGrids(String[] grid) { int N = grid.length; grids = new int[N * 3][N * 3]; for (int i = 0; i &lt; grid.length; i++) { for (int j = 0; j &lt; grid[i].length(); j++) { if (grid[i].charAt(j) == '/') { grids[i * 3 + 2][j * 3] = 1; grids[i * 3 + 1][j * 3 + 1] = 1; grids[i * 3][j * 3 + 2] = 1; } else if (grid[i].charAt(j) == '\\\\') { grids[i * 3][j * 3] = 1; grids[i * 3 + 1][j * 3 + 1] = 1; grids[i * 3 + 2][j * 3 + 2] = 1; } } } } private int dfs(int r, int c) { // 越界返回0 if (r &lt; 0 || r &gt;= grids.length || c &lt; 0 || c &gt;= grids[r].length) return 0; // 遇到墙（数字1）返回0 if (grids[r][c] == 1) return 0; // 将空白块改为1，并向他四周遍历，结果返回1 grids[r][c] = 1; dfs(r - 1, c); dfs(r + 1, c); dfs(r, c - 1); dfs(r, c + 1); return 1; }}","link":"/2019/07/01/regions-cut-by-slashes/"},{"title":"shopping-offers","text":"题目链接：shopping-offers 题目描述在LeetCode商店中， 有许多在售的物品。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。现给定每个物品的价格，每个大礼包包含物品的清单，以及待购物品清单。请输出确切完成待购清单的最低花费。每个大礼包的由一个数组中的一组数据描述，最后一个数字代表大礼包的价格，其他数字分别表示内含的其他种类物品的数量。任意大礼包可无限次购买。 说明: 最多6种物品， 100种大礼包。 每种物品，你最多只需要购买6个。 你不可以购买超出待购清单的物品，即使更便宜。 题目分析 首先，改题目明显具有最有子结构的特征，因此可以采用动态规划算法。 最优值，如果采用深搜，明显具有可以剪枝特征。 算法深度优先遍历（Depth-first-Search）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution { public int shoppingOffers(List &lt; Integer &gt; price, List &lt; List &lt; Integer &gt;&gt; special, List &lt; Integer &gt; needs) { return dfs(price, special, needs, 0); } public int dfs(List &lt; Integer &gt; price, List &lt; List &lt; Integer &gt;&gt; special, List &lt; Integer &gt; needs, int offerIndex) { if (offerIndex == special.size()) { // 不采用套餐 int cost = 0; for (int i = 0; i &lt; needs.size(); i++) cost += price.get(i) * needs.get(i); return cost; } int cost = Integer.MAX_VALUE; // 采用当前套餐 List&lt;Integer&gt; offer = special.get(offerIndex); if (check(offer, needs)) { for (int i = 0; i &lt; needs.size(); i++) { needs.set(i, needs.get(i) - offer.get(i)); } cost = Math.min(cost, offer.get(price.size()) + dfs(price, special, needs, offerIndex)); // 继续采用当前套餐 cost = Math.min(cost, offer.get(price.size()) + dfs(price, special, needs, offerIndex + 1)); // 采用下一个套餐 // 将当前需要商品数还原 for (int i = 0; i &lt; needs.size(); i++) { needs.set(i, needs.get(i) + offer.get(i)); } } // 不采用当前套餐 cost = Math.min(cost, dfs(price, special, needs, offerIndex + 1)); return cost; } // 检验当前套餐是否可用 private boolean check(List&lt;Integer&gt; offer, List&lt;Integer&gt; needs) { for (int i = 0; i &lt; needs.size(); i++) { if (offer.get(i) &gt; needs.get(i)) return false; } return true; }} 深度优先遍历+剪枝（Depth-first-Search+Pruning）代码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution { int total = Integer.MAX_VALUE; // 总花费 public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) { dfs(price, special, needs, 0, 0); return total; } private void dfs(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, int offerIndex, int cost) { if (cost &gt;= total) return; // 剪枝 if (offerIndex == special.size()) { // 不采用套餐 for (int i = 0; i &lt; needs.size(); i++) cost += price.get(i) * needs.get(i); total = Math.min(total, cost); return; } // 采用当前套餐 List&lt;Integer&gt; offer = special.get(offerIndex); if (check(offer, needs)) { for (int i = 0; i &lt; needs.size(); i++) { needs.set(i, needs.get(i) - offer.get(i)); } dfs(price, special, needs, offerIndex, cost + offer.get(price.size())); // 继续采用当前套餐 dfs(price, special, needs, offerIndex + 1, cost + offer.get(price.size())); // 采用下一个套餐 for (int i = 0; i &lt; needs.size(); i++) { needs.set(i, needs.get(i) + offer.get(i)); } } // 不采用当前套餐 dfs(price, special, needs, offerIndex + 1, cost); } // 检验当前套餐是否可用 private boolean check(List&lt;Integer&gt; offer, List&lt;Integer&gt; needs) { for (int i = 0; i &lt; needs.size(); i++) { if (offer.get(i) &gt; needs.get(i)) return false; } return true; } } 动态规划（Dynamic-Programming）代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution { public int shoppingOffers(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs) { Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); map.put(0, 0); dp(price, special, needs, map); int key = hashcode(needs); return map.get(key); } private void dp(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs, Map&lt;Integer, Integer&gt; map) { int code = hashcode(needs); if (map.get(code) != null) return; // 已被解决的子问题，剪枝 int result = 0; // 不采用套餐 for (int i = 0; i &lt; needs.size(); i++) { result += price.get(i) * needs.get(i); } for (List&lt;Integer&gt; offer : special) { if (check(offer, needs)) { List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; needs.size(); i++) temp.add(needs.get(i) - offer.get(i)); dp(price, special, temp, map); result = Math.min(result, map.get(hashcode(temp)) + offer.get(price.size())); // 此时，子问题一定已经被解决，直接从map中获取 } } map.put(code, result); // 将当前最优解放入map中 } // 检验当前套餐是否可用 private boolean check(List&lt;Integer&gt; offer, List&lt;Integer&gt; needs) { for (int i = 0; i &lt; needs.size(); i++) { if (offer.get(i) &gt; needs.get(i)) return false; } return true; } // 将当前需要转化成一个hash值，因为说明最多买6中商品 private int hashcode(List&lt;Integer&gt; needs) { int result = 0; for (int need : needs) result = result * 6 + need; return result; }}","link":"/2019/08/04/shopping-offers/"}],"tags":[{"name":"Tree","slug":"Tree","link":"/tags/Tree/"},{"name":"Depth-first-Search","slug":"Depth-first-Search","link":"/tags/Depth-first-Search/"},{"name":"Breadth-first-Search","slug":"Breadth-first-Search","link":"/tags/Breadth-first-Search/"},{"name":"Stack","slug":"Stack","link":"/tags/Stack/"},{"name":"Union-Find","slug":"Union-Find","link":"/tags/Union-Find/"},{"name":"Bit-Manipulation","slug":"Bit-Manipulation","link":"/tags/Bit-Manipulation/"},{"name":"Graph","slug":"Graph","link":"/tags/Graph/"},{"name":"Dynamic-Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"Medium","slug":"leetcode/Medium","link":"/categories/leetcode/Medium/"}]}